/* 思路分析：
看到这个题目，我们的第一反应是顺序扫描整个数组。每扫描到一个数组的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n个数字。由于每个数字都要和O(n)这个数字比较，因此这个算法的时间复杂度为O(n^2)。
我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿ta和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。

(a) 把长度为4的数组分解成两个长度为2的子数组；
(b) 把长度为2的数组分解成两个成都为1的子数组；
(c) 把长度为1的子数组 合并、排序并统计逆序对 ；
(d) 把长度为2的子数组合并、排序，并统计逆序对；
在上图（a）和（b）中，我们先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。
同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。
接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。
我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，
如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为copy） 中的数字是递增排序的。
在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。
过程：先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。参考代码如下：
*/

#include <vector>
#include <stdio.h>
#include <algorithm>

using namespace std;


/*class Solution {
public:
	
	int InversePairs(vector<int> data) {
		int length = data.size();
		if(length <= 0)
		{
			return 0;
		}
		
		vector<int> temp(length);
//		for(int i=0;i<length;i++)
//			temp.push_back(data[i]);
		
		long long count = InversePairsCore(data, temp, 0, length - 1);

		for(int i = 0; i < data.size() - 1; i++)
		{
			if(data[i] > data[i + 1])
			{
						return count%1000000007;
			}
		}
		
		return count%1000000007;
    }
	
    long long InversePairsCore(vector<int> &data,vector<int> &temp,int start,int end)
    {
		if(start >= end)
		{
			return 0;
		}
		
		int mid = (start + end) >> 1;
		long long leftcount = InversePairsCore(data, temp, start, mid);
		long long rightcount = InversePairsCore(data, temp, mid + 1, end);
		
		long long count = merge(data, temp, start, mid, end);
		
		return leftcount + rightcount + count;
		
    }
	

	
	int merge(vector<int> &data, vector<int> &temp, int start, int mid, int end)
	{
		int i = mid;	//左边数组最后一个元素索引
		int j = end;	//右边数组最后一个元素索引
		long long count = 0;
		int k = end;
		
		while(i >= start && j >= mid + 1)
		{
			if(data[i] > data[j])	//左边元素大于右边元素
			{
				temp[k--] = data[i--];
				count += j - mid;	//个数 j - (mid + 1) + 1
			}
			else
			{
				temp[k--] = data[j--]; 
			}
		}
		
		//左边数组还有元素，拷贝到temp
		while(i >= start)
		{
			temp[k--] = data[i--];
		}
		
		//右边数组还有元素，拷贝到temp
		while(j >= mid + 1)
		{
			temp[k--] = data[j--];
		}
		
		k = end;
		while(end >= start)
		{
			data[end--] = temp[k--];
		}
		
		return count;
	}
	
	vector< pair<int, int> > vec;
};
 */

class Solution {
public:
    long long nums = 0;
    int InversePairs(vector<int> data) {
        vector<int> temp=data;
        MSort(data, temp, 0, data.size()-1);
		//  cout << "nums:" << nums << endl;
        return nums % 1000000007;
    }

    void Merge(vector<int> &data, vector<int> &temp, int begin, int mid, int end)
    {
        int start = begin;//记录开始位置
        int left = begin;
        int right = mid + 1;
        while (left<=mid && right <=end)
        {
            if (data[left] < data[right])
            {
                temp[begin++] = data[left++];
            }
            else
            {
                temp[begin++] = data[right++];
                nums += mid - left + 1;
            }
        }
        while (left<=mid)
        {
            temp[begin++] = data[left++];
        }
        while (right <= end)
        {
            temp[begin++] = data[right++];
        }
        while (start<=end)
        {
            data[start] = temp[start];
            start++;
        }
    }

    void MSort(vector<int> &data, vector<int> &temp, int begin,int end)
    {
        int mid;
        if (begin < end)
        {
            mid = (begin + end) / 2;
            MSort(data, temp, begin, mid);
            MSort(data, temp, mid+1,end);
            Merge(data, temp, begin, mid, end);
        }
    }
};

int main()
{
	vector<int> vec = {448045,1996558,1893566,1619930,355248,236498,713257,86874,848748,320167,1967682,1481416,829945,1445369,1383138,1788619,2454,1821266,639476,287680,632549,1257841,1044060,318444,1631277,1085870,152693,1643512,109781,743118,205043,1074178,1256029,614961,694109,127629,851459,1407366,214503,216559,1727533,182185,214327,1073831,143906,1597465,1378802,146360,1935083,18278,950392,1083984,1792471,510804,1918781,1423749,1596674,71474,1583613,1706456,1330944,1788657,780634,586973,403618,1991095,1230955,1771430,1398461,1445458,504341,1642347,143996,718669,1232530,287902,832486,611332,950615,767570,1145963,1901007,367906,938434,411812,286687,878535,524838,874513,462149,231294,205458,767158,1528281,1308783,1687128,1519376,539738,1458558,1434190,501549,1962900,1076537,645545,1197921,309067,933447,30407,1436751,400414,1314329,582714,817774,1682236,37501,1745938,1968923,916036,270776,1359789,1894537,1018423,1565247,661695,546704,1390382,865176,582432,446473,323734,16622,948022,802986,1609511,1593567,907,434930,1043366,547667,1871682,1443781,1861996,970748,777907,60584,1524601,523845,545860,956990,794621,1905649,851527,1813044,1987248,29575,876100,1377630,894751,1458533,1824103,1734837,1991507,772125,1054176,117371,882044,1055083,552301,1925411,119102,940335,1885544,1981099,427436,1179803,558035,1952037,1703648,1103895,1425379,498269,1009544,793259,827666,996792,822834,1703766,374423,233937,1678651,714878,485126,1670159,3356,1539302,1787530,885400,1110738,856183,1327163,1229840,1796519,1729059,1210939,740307,908862,1768975,1208696,612510,1389222,634076,1627132,398767,1427335,454798,1395559,250169,674916,286334,1000458,353568,1517565,1485584,540079,1520921,1541239,843961,406321,651977,1700144,249837,1881817,13015,1978896,1609109,753322,1404111,1894436,1962019,532973,1283658,596095,160105,1682425,539782,1131255,1594337,789951,322524,397023,306761,676092,1914588,308697,1732523,1435509,1849936,576484,358183,501913,792980,1124372,383731,805996,1619620,509192,75670,1023731,403628,37689,73057,1687286,1150136,749514,1886064,1689918,1880770,1996753,996221,203294,393776,1819334,1395738,824717,128032,1644613,776578,1977968,221097,1651113,479882,1014077,775485,1379965,336425,911458,1889157,412096,451541,292785,966137,524598,496423,632626,1274113,898839,838896,1671235,895592,1835118,390881,1805721,1654452,1786619,1146790,1782484,1947584,1923368,276805,168681,90834,1273039,1699110,1382671,653004,551888,294129,1058513,963984,745671,1867650,1270269,364073,1079099,544382,1262913,1917996,731969,674857,269466,1122850,996930,440270,1425821,143720,739107,1373405,67089,1015912,58438,674275,288951,1757549,56946,1458307,309437,351076,516820,1789773,1096747,384470,236246,883368,1264895,1831698,1944103,527808,266046,676072,1719018,535512,1798923,715948,975782,1741096,859669,1714889,1114502,1443110,1247153,1689292,117385,52456,1446841,690683,1510763,272630,1041759,27583,578755,654858,928405,815002,1538227,193301,1163052,1482330,1237461,1429098,674754,956479,480962,473677,188780,1456744,731126,1048449,1687986,361980,1007911,1451491,51272,1641648,1503948,1498114,332331,1014711,287096,1374091,1558647,865852,545301,487052,197206,83528,1196705,1876610,82210,434167,1305708,756965,1390646,1786670,1746994,1579426,1759766,478120,1144227,1964104,840100,152138,1415596,891373,1793786,919544,905839,642470,450607,1192935,16561,525606,575139,561862,1529011,1288697,1161743,725716,1165307,1243953,1159883,471015,918,1066882,774037,1747913,1162660,1050156,226033,306888,1014260,1582486,975378,946208,473859,1285517,382104,1379698,1927987,832712,1088985,460900,1874670,1664125,1022762,1403681,1469174,700857,129398,634482,1944811,1805633,1105497,462081,872515,395887,209994,35176,1446043,952380,858416,976655,534866,1833794,1922864,1525077,1119311,304968,1421127,1563650,1654032,510112,24550,1528703,690589,1047313,1448736,159764,264522,1578134,794246,209333,1900120,416095,671415,772635,1328334,1397761,1324163,1290729,866493,182579,267385,1917711,532726,190249,1442788,168389,495217,863915,1732040,149250,1890380,1756590,194305,1097321,1320255,1643041,1773437,1584778,1737528,1084035,310463,1637648,16483,981878,926635,1344817,895992,250799,635547,1762485,949730,902932,1680197,1482456,1609533,1122985,167198,104750,503253,1899238,770352,909985,172180,1481009,523658,1492436,1124051,297096,1593566,1377931,1381131,1904029,1015579,1913966,1402260,1942214,1258784,298252,709365,410683,60737,1659096,1829967,1740934,1657904,1439500,1380272,1825102,60602,399877,240692,1347307,1309862,412873,828316,1833520,421661,468719,130616,15227,1846650,28100,435608,862229,1942066,1837868,1320796,1717202,136120,30161,644237,713210,205609,474204,454144,1863514,1913704,350768,204968,490659,750645,445661,1837966,576859,1374886,1182634,410380,1796547,1651354,1057348,328126,14356,1601800,1280086,876586,60219,1117955,713734,1777421,1770427,743895,421659,483637,1465857,895863,1454134,1329371,1325920,321254,50691,332931,1071900,1012704,687249,1648759,387590,1869883,575491,700489,37589,1632840,1544967,51946,1234640,825054,1444884,1811211,459361,158618,1588633,229788,1418865,526644,1229778,884722,1938859,1200264,214093,1264779,1521518,781137,114062,593418,1793841,801311,758530,181432,1187547,1334021,1398273,1225136,1483213,943241,1277082,1234206,1768295,1238318,1045417,744008,1396936,1150402,973796,815802,1677046,719926,1700524,1615906,1920190,430970,1397037,1441709,1728459,1511100,551479,1522300,828763,1310009,220084,16310,1160383,1618358,1241447,1159948,561599,1034881,394154,846246,273200,1439572,1590254,186488,1106326,1080402,1518642,783373,1800329,1219167,399279,1720519,166489,1796316,1678580,1894948,1823768,230060,1933600,652532,56421,153685,1185194,1733156,1772043,426641,893105,849994,1977875,1287259,212592,767427,1243183,1802846,1470267,349510,1399600,988910,1132883,1199929,724429,48514,1436801,890918,361182,1115381,1302218,701303,1861793,1235818,1353835,1918215,1905855,1055381,1651371,1677898,1998375,544476,1044244,1976250,348088,1256836,1260029,1591271,1576034,730296,457133,975635,1719206,106368,175564,443635,154882,1612365,1850905,1032417,1244099,1669475,1733720,1105892,905294,1603907,1024107,1327501,659288,1191831,1005400,657663,252659,565996,1150265,600747,1822833,410294,708371,1398867,1656943,1165504,890854,1376149,1271873,1066419,336137,1943107,1195136,187042,975524,955587,1856518,1225596,61480,1278164,829503,1601939,605665,1488792,1310122,127417,662807,1562782,693414,1813073,163529,1032599,223367,1388252,947818,1880310,553757,1838673,1772812,341982,1421444,108949,285089,1132932,812343,1776966,88520,1185213,1002562,666352,463377,1832066,784643,1585395,1837210,94766,229164,500017,1657548,922578,313090,337429,471529,1052810,1725682,1419348,1449472,795791,1774373,1738636,1137773,1195817,363937,1939214,845101,1176281,1716180,1449973,361494,1235095,116325,1341224,1067161,900969,1442971,1420723,995735,1672135,1920740,1169635,1111066,750183,23416,1582595,1802993,265450,1518295,1768817,1577593,1809020,1507454,715366,1521189,1871391,1170933,366291,1564024,1403465,1816264,441871,638560,1932590,299447,1705721,1349911,1742418,1126444,861998,1930905,1563537,547985,1041971,313720,571401,1140919,633065,1353204,659214,918234,9307};
	Solution sol;
	int t = sol.InversePairs(vec);
	printf("%d", t);
	
	return 0;
	
}
